## 问题描述

给定一个无序的数组 nums，将它重新排列成 nums[0] < nums[1] > nums[2] < nums[3]... 的顺序。

> 输入: nums = [1, 5, 1, 1, 6, 4]  
输出: 一个可能的答案是 [1, 4, 1, 5, 1, 6]

## 算法思路

O(nlogn)的算法还是比较简单的，排序后把大的元素插在小元素中就可以了，关键是O(n)怎么解决。一开始想的局部去做，就是每三个元素去进行调整，但是这样不对，其实局部的做法都不对。然后看网上的解答，明白了我们需要的只是较大的那些元素，至于他们是不是排好序的无所谓，这样来说，排序对本题目来讲是存在冗余操作的。既然不需要把较大的元素排好序，那么只需要找出这些较大元素就好了，自然而然就是找中位数，然后把元素分成两部分，接着按照O（nlogn）做法就可以了，至于空间复杂度为O(1)这就涉及到一些编程技巧了，我觉得不重要。在O(n)时间内找中位数，目前大部分做法都是用快排里面的划分函数，但这也只是期望O(n)。