## 问题描述

我们把玻璃杯摆成金字塔的形状，其中第一层有1个玻璃杯，第二层有2个，依次类推到第100层，每个玻璃杯(250ml)将盛有香槟。

从顶层的第一个玻璃杯开始倾倒一些香槟，当顶层的杯子满了，任何溢出的香槟都会立刻等流量的流向左右两侧的玻璃杯。当左右两边的杯子也满了，就会等流量的流向它们左右两边的杯子，依次类推。（当最底层的玻璃杯满了，香槟会流到地板上）

例如，在倾倒一杯香槟后，最顶层的玻璃杯满了。倾倒了两杯香槟后，第二层的两个玻璃杯各自盛放一半的香槟。在倒三杯香槟后，第二层的香槟满了 - 此时总共有三个满的玻璃杯。在倒第四杯后，第三层中间的玻璃杯盛放了一半的香槟，他两边的玻璃杯各自盛放了四分之一的香槟，如下图所示。

> 示例 2:
输入: poured(倾倒香槟总杯数) = 2, query_glass(杯子的位置数) = 1, query_row(行数) = 1  
输出: 0.5  
解释: 我们在顶层（下标是（0，0）倒了两杯香槟后，有一杯量的香槟将从顶层溢出，位于（1，0）的玻璃杯和（1，1）的玻璃杯平分了这一杯香槟，所以每个玻璃杯有一半的香槟。

## 算法思路

比较典型的dp，类似于入门题目的三角形求和最大的路径，只不过在dp计算的时候加的是父节点减一后的值。

## 代码

```c++
class Solution {
public:
    double champagneTower(int poured, int query_row, int query_glass) {
        /*
        dp[i][j] = (dp[i-1][j]-1) / 2 + (dp[i][j]-1) / 2
        */
        
        vector<double> dp(query_row+1, 0);
        
        dp[0] = poured;
        for(int i = 1; i <= query_row; i++){
            vector<double> tmp(dp.size(), 0);
            for(int j = i; j >= 0; j--){
                tmp[j] += max((dp[j]-1)/2, 0.0);
                if(j-1>=0){
                    tmp[j] += max((dp[j-1]-1)/2, 0.0);
                }
                
            }
            dp = tmp;
        }
        return min(dp[query_glass], 1.0);
        
    }
};
```
