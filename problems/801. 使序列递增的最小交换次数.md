## 问题描述

我们有两个长度相等且不为空的整型数组 A 和 B 。

我们可以交换 A[i] 和 B[i] 的元素。注意这两个元素在各自的序列中应该处于相同的位置。

在交换过一些元素之后，数组 A 和 B 都应该是严格递增的（数组严格递增的条件仅为A[0] < A[1] < A[2] < ... < A[A.length - 1]）。

给定数组 A 和 B ，请返回使得两个数组均保持严格递增状态的最小交换次数。假设给定的输入总是有效的。

> 示例:  
输入: A = [1,3,5,4], B = [1,2,3,7]  
输出: 1  
解释:   
交换 A[3] 和 B[3] 后，两个数组如下:
A = [1, 3, 5, 7] ， B = [1, 2, 3, 4]
两个数组均为严格递增的。

## 算法思路

一开始感觉遍历的时候没有重复计算，以为是回溯，即每个位置换或者不换，然后做一下剪枝应该就可以，然后就用递归去写了，结果发现超时，然后发现，其实是有重复计算的（到这里其实就已经确定不是回溯而是dp了），然后用递归+记忆化去做，超时。。。（感觉以后遇到dp题目可以直接放弃递归+记忆了），然后就是把递归程序改成dp的过程，我感觉能把递归+记忆化的程序写出来，改成递归就挺简单的了。递推式：

其中，dp[i][0]表示在第i个位置不换的最小次数，dp[i][1]表示在第i个位置换的最小次数。

## 代码

```c++
class Solution {
public:
    int inf = 100000;
    int minSwap(vector<int>& A, vector<int>& B) {
        vector<vector<int>> dp(A.size(), vector<int>(2, inf));
        dp[0][0] = 0; dp[0][1] = 1;
        for(int i = 1; i < A.size(); i++){
            // dp[i][0]
            int l = inf, r= inf;
            if(A[i-1] < A[i] && B[i-1] < B[i]){
                l = min(dp[i-1][0], dp[i][0]);
            }
            swap(A[i-1], B[i-1]);
            if(A[i-1] < A[i] && B[i-1] <B[i]){
                r  = min(dp[i-1][1], dp[i][0]);
            }
            swap(A[i-1], B[i-1]);
            dp[i][0] = min(l,r);
            // dp[i][1]
            l = inf, r = inf;
            swap(A[i], B[i]);
            if(A[i-1] < A[i] && B[i-1] < B[i]){
                l = min(dp[i-1][0], dp[i][1]) + 1;
            }
            swap(A[i-1], B[i-1]);
            if(A[i-1] < A[i] && B[i-1] < B[i]){
                r = min(dp[i-1][1], dp[i][1]) + 1;
            }
            dp[i][1] = min(l,r);
            swap(A[i-1], B[i-1]);
            swap(A[i], B[i]);
        }
        return min(dp[A.size()-1][0], dp[A.size()-1][1]);
    }
};
```