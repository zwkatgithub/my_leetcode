## 问题描述

爱丽丝参与一个大致基于纸牌游戏 “21点” 规则的游戏，描述如下：

爱丽丝以 0 分开始，并在她的得分少于 K 分时抽取数字。 抽取时，她从 [1, W] 的范围中随机获得一个整数作为分数进行累计，其中 W 是整数。 每次抽取都是独立的，其结果具有相同的概率。

当爱丽丝获得不少于 K 分时，她就停止抽取数字。 爱丽丝的分数不超过 N 的概率是多少？

> 输入：N = 6, K = 1, W = 10  
输出：0.60000  
说明：爱丽丝得到一张卡，然后停止。
在 W = 10 的 6 种可能下，她的得分不超过 N = 6 分。

## 算法思路

这道题很有意思，尤其是编写代码过程中那些非常需要注意的地方。首先，肯定是dp，不可能硬去计算。那么记p[i]为分数为i时的概率，那么可以很容易的写出p的递推式：p[i] = sum(p[i-j])\*1.0/W，其中j是从1到W,注意，这里把p[0]设为1可以方便计算。回到问题，超过K但是小于N的这部分可以倒推回去，例如，N=21，K=17，W=10，那么可以有以下情况：
p[7] \* p[last=10] \* 1.0/W +
p[8] \* (p[last=10]+p[last=9]) \* 1.0/W +
...
p[12] \* (p[last=9] + p[last=8] ... +p[last=5]) \* 1.0/W +
...
p[16] \* (p[last=1]) \* 1.0/W

即，从max(K-W, 0)开始，到K-1结束是可能的除最后一张牌的分数i，而最后一张牌可能的情况又是有min(i+W-K+1, N-K+1)种。
注意，在计算p的时候，如果用二层循环会超时，所以用一个双端队列去保存最近的W个p值。

## 代码

```c++
class Solution {
public:
    double new21Game(int N, int K, int W) {
        vector<double> p(N, 0.0);
        if(K == 0) return 1.0;
        p[0] = 1.0;
        double t = 0;
        deque<double> dd;
        for(int i = 1; i < N; i++){
            if(dd.size() == W){
                t -= dd.front();
                dd.pop_front();
                dd.push_back(p[i-1]);
                t += p[i-1];
            }else{
                dd.push_back(p[i-1]);
                t += p[i-1];
            }
            p[i] = 1.0/W * t;
        }
        double res = 0;
        for(int k = max(K-W, 0); k <= K-1; k++){
            res += p[k] * min(k+W-K+1, N-K+1) * 1.0/W;
        }
        return res;
        
    }
};
```
