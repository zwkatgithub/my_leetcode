## 问题描述

给定一个整数数组 A，找到 min(B) 的总和，其中 B 的范围为 A 的每个（连续）子数组。

由于答案可能很大，因此返回答案模 10^9 + 7。

> 输入：[3,1,2,4]  
输出：17  
解释：
子数组为 [3]，[1]，[2]，[4]，[3,1]，[1,2]，[2,4]，[3,1,2]，[1,2,4]，[3,1,2,4]。 
最小值为 3，1，2，4，1，1，2，1，1，1，和为 17。

## 算法思路

状态空间是指数级的一定需要dp，因为是连续数组，那么每个位置的连续数组都可以在上一个位置的连续数组中添加当前位置元素就可以了，这样的话只需要分两组就可以了，一个是有比当前元素小的数组，一个是没有比当前元素小的数组，即找到最近的比当前小的那个数的位置，把它的结果和当前元素到该元素之间的数量相乘的结果相加就是当前元素的结果，举个例子：

3,1,2,4，维护一个数组和数组m,为了方便写代码可以在0位置放一个0，则m[i] = (m[j] + (i-j)\*A[i-1]) % mod就是递推式，其中，j是最近小的数的位置。在这个例子中，m[1] = 3, m[2] = 2, m[3] = 2+ 1\*2 = 4, m[4] = 4 + 1\*4 = 8, 结果为3+2+4+8 = 17

使用单调栈来加速代码。
## 代码

```c++
class Solution {
public:
    int mod = 1000000007;
    int sumSubarrayMins(vector<int>& A) {
        vector<int> m(A.size()+1, 0);
        // dan diao zhan
        stack<int> si;
        int res = 0;
        for(int i = 1; i <= A.size(); i++){
            // 1. find last min
            int j = 0;
            // while(j > 0 && A[j-1]>A[i-1]){
            //     j--;
            // }
            while(!si.empty() && A[si.top()-1] > A[i-1]){
                si.pop();
            }
            if(!si.empty()){
                j = si.top();
            }
            si.push(i);
            
            m[i] = (m[j] + (i-j)*A[i-1]) % mod;
            res = (res + m[i])% mod;
        }
        return res;
    }
};
```
